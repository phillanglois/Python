
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1. Complexités &#8212; Algo-Prog 2023</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2. Récursivité" href="6-recursivite.html" />
    <link rel="prev" title="2. Entrées-sorties simples avec des fichiers" href="3-ES-fichiers.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo2023.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Algo-Prog 2023</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../bonjour.html">
                    Bienvenu en Algo-Prog !
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Présentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="0-presentation-2023.html">
   1. Algorithmique et Programmation en 2022
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="competences.html">
   2. Compétences
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Les bases
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="1-fonctions.html">
   1. Fonctions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="3-ES-fichiers.html">
   2. Entrées-sorties simples avec des fichiers
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Algorithmique
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1. Complexités
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="6-recursivite.html">
   2. Récursivité
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Programmation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="5-types_composes.html">
   1. Les types composés
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="7-fonctions-avancees.html">
   2. Sous-programme et affectation – aspects avancés
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="9-ES-avancees.html">
   3. Les entrées-sorties (E/S) : aspects avancés
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="11-modules-utiles.html">
   4. Modules utiles
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Annexes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="a0-boucles-avancees.html">
   1. Boucles, tableaux et fonctions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="a1-booleens.html">
   2. Annexe : les booléens en python (&gt;3.6)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="a2-ndarray.html">
   3. Les ‘ndarray’ : de vrais tableaux en python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="a3-exceptions.html">
   4. Exceptions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  TD
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../td/prealable-td.html">
   1. Préalables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../td/td1.html">
   2. Feuille 1
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../td/td2.html">
   3. Feuille 2
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../td/td3.html">
   4. Feuille 3
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../td/td4.html">
   5. Feuille 4
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../td/td5.html">
   6. Feuille 5
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/phillanglois/Algo-Prog-2023/main?urlpath=tree/algoprog2023/cm/4-complexite.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/phillanglois/Algo-Prog-2023/issues/new?title=Issue%20on%20page%20%2Fcm/4-complexite.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/cm/4-complexite.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivations">
   1.1. Motivations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exemples-introductifs">
   1.2. Exemples introductifs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pb1-calculer-la-somme-de-n-entiers">
     1.2.1. Pb1 : calculer la somme de
     <span class="math notranslate nohighlight">
      \(n\)
     </span>
     entiers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pb2-recherche-de-l-indice-d-une-valeur-parmi-n-stockees-dans-un-tableau">
     1.2.2. Pb2 : recherche de l’indice d’une valeur parmi
     <span class="math notranslate nohighlight">
      \(n\)
     </span>
     stockées dans un tableau
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#premiere-analyse-empirique-des-complexites-en-temps-et-en-espace">
     1.2.3. Première analyse empirique des complexités en temps et en espace
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#complexite-en-temps">
       Complexité en temps
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#complexite-en-espace">
       Complexité en espace
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-f-taille">
   1.3. complexité = f(taille)
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#objectifs-d-une-analyse-de-complexite-en-temps">
     1.3.1. Objectifs d’une analyse de complexité en temps
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#un-modele-de-calcul-pour-la-complexite-en-temps">
     1.3.2. Un modèle de calcul pour la complexité en temps
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#application-au-pb1">
     1.3.3. Application au Pb1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#du-modele-pour-l-algorithme-a-la-mesure-du-temps-d-execution-d-un-programme">
     1.3.4. Du modèle pour l’algorithme à la mesure du temps d’exécution d’un programme
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#application-au-pb-2">
     1.3.5. Application au Pb 2
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conclusions-de-ces-deux-analyses-de-complexites-en-temps">
     1.3.6. Conclusions de ces deux analyses de complexités en temps
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   1.4. Complexité en espace
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exemple-avec-pb1">
     1.4.1. Exemple avec Pb1
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#un-autre-exemple-de-complexite-polynomiale-en-temps">
   1.5. Un autre exemple de complexité polynomiale en temps
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexite-quadratique-du-produit-matrice-x-vecteur">
     1.5.1. Complexité quadratique du produit matrice x vecteur
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mesures-du-temps-d-execution-du-produit-matrice-vecteur">
     1.5.2. Mesures du temps d’exécution du produit matrice-vecteur
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexite-en-memoire-du-produit-matrice-x-vecteur">
     1.5.3. Complexité en mémoire du produit matrice x vecteur
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-et-log-2">
   1.6. Complexité et
   <span class="math notranslate nohighlight">
    \(\log_2\)
   </span>
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pas-que-des-puissances-entieres-de-la-taille-du-pb">
     1.6.1. Pas que des puissances entières de la taille du pb
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#reduire-la-complexite-diviser-pour-regner">
     1.6.2. Réduire la complexité ? Diviser pour régner !
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-asymptotique">
   1.7. Complexité asymptotique
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#quelle-complexite">
     1.7.1. Quelle complexité ?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexite-asymptotique-et-notations-de-landau">
     1.7.2. Complexité asymptotique et notations de Landau
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#star-expression-formalisee-et-principales-proprietes-de-ces-notations">
       (
       <span class="math notranslate nohighlight">
        \(\star\)
       </span>
       ) Expression formalisée et principales propriétés de ces notations
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#expressions-et-equivalents-asymptotiques-a-connaitre">
     1.7.3. Expressions et équivalents asymptotiques à connaître
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-d-algorithmes-iteratifs">
   1.8. Complexité d’algorithmes itératifs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#iterations-classiques">
     1.8.1. Itérations classiques
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#star-complexite-d-algorithmes-recursifs">
   1.9. (
   <span class="math notranslate nohighlight">
    \(\star\)
   </span>
   ) Complexité d’algorithmes récursifs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fonction-de-complexite-relation-de-recurrence">
     1.9.1. Fonction de complexité = relation de récurrence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#c-n-fonction-de-c-n-1">
     1.9.2.
     <span class="math notranslate nohighlight">
      \(C(n)\)
     </span>
     fonction de
     <span class="math notranslate nohighlight">
      \(C(n-1)\)
     </span>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#c-n-fonction-de-c-n-2">
     1.9.3.
     <span class="math notranslate nohighlight">
      \(C(n)\)
     </span>
     fonction de
     <span class="math notranslate nohighlight">
      \(C(n/2)\)
     </span>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#star-star-autres-cas">
     1.9.4. (
     <span class="math notranslate nohighlight">
      \(\star\star\)
     </span>
     ) Autres cas
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#synthese">
   1.10. Synthèse
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#avoir-les-idees-claires">
     1.10.1. Avoir les idées claires
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#savoir-faire">
     1.10.2. Savoir-faire
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Complexités</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivations">
   1.1. Motivations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exemples-introductifs">
   1.2. Exemples introductifs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pb1-calculer-la-somme-de-n-entiers">
     1.2.1. Pb1 : calculer la somme de
     <span class="math notranslate nohighlight">
      \(n\)
     </span>
     entiers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pb2-recherche-de-l-indice-d-une-valeur-parmi-n-stockees-dans-un-tableau">
     1.2.2. Pb2 : recherche de l’indice d’une valeur parmi
     <span class="math notranslate nohighlight">
      \(n\)
     </span>
     stockées dans un tableau
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#premiere-analyse-empirique-des-complexites-en-temps-et-en-espace">
     1.2.3. Première analyse empirique des complexités en temps et en espace
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#complexite-en-temps">
       Complexité en temps
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#complexite-en-espace">
       Complexité en espace
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-f-taille">
   1.3. complexité = f(taille)
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#objectifs-d-une-analyse-de-complexite-en-temps">
     1.3.1. Objectifs d’une analyse de complexité en temps
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#un-modele-de-calcul-pour-la-complexite-en-temps">
     1.3.2. Un modèle de calcul pour la complexité en temps
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#application-au-pb1">
     1.3.3. Application au Pb1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#du-modele-pour-l-algorithme-a-la-mesure-du-temps-d-execution-d-un-programme">
     1.3.4. Du modèle pour l’algorithme à la mesure du temps d’exécution d’un programme
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#application-au-pb-2">
     1.3.5. Application au Pb 2
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conclusions-de-ces-deux-analyses-de-complexites-en-temps">
     1.3.6. Conclusions de ces deux analyses de complexités en temps
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   1.4. Complexité en espace
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exemple-avec-pb1">
     1.4.1. Exemple avec Pb1
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#un-autre-exemple-de-complexite-polynomiale-en-temps">
   1.5. Un autre exemple de complexité polynomiale en temps
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexite-quadratique-du-produit-matrice-x-vecteur">
     1.5.1. Complexité quadratique du produit matrice x vecteur
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mesures-du-temps-d-execution-du-produit-matrice-vecteur">
     1.5.2. Mesures du temps d’exécution du produit matrice-vecteur
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexite-en-memoire-du-produit-matrice-x-vecteur">
     1.5.3. Complexité en mémoire du produit matrice x vecteur
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-et-log-2">
   1.6. Complexité et
   <span class="math notranslate nohighlight">
    \(\log_2\)
   </span>
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pas-que-des-puissances-entieres-de-la-taille-du-pb">
     1.6.1. Pas que des puissances entières de la taille du pb
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#reduire-la-complexite-diviser-pour-regner">
     1.6.2. Réduire la complexité ? Diviser pour régner !
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-asymptotique">
   1.7. Complexité asymptotique
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#quelle-complexite">
     1.7.1. Quelle complexité ?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexite-asymptotique-et-notations-de-landau">
     1.7.2. Complexité asymptotique et notations de Landau
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#star-expression-formalisee-et-principales-proprietes-de-ces-notations">
       (
       <span class="math notranslate nohighlight">
        \(\star\)
       </span>
       ) Expression formalisée et principales propriétés de ces notations
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#expressions-et-equivalents-asymptotiques-a-connaitre">
     1.7.3. Expressions et équivalents asymptotiques à connaître
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexite-d-algorithmes-iteratifs">
   1.8. Complexité d’algorithmes itératifs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#iterations-classiques">
     1.8.1. Itérations classiques
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#star-complexite-d-algorithmes-recursifs">
   1.9. (
   <span class="math notranslate nohighlight">
    \(\star\)
   </span>
   ) Complexité d’algorithmes récursifs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fonction-de-complexite-relation-de-recurrence">
     1.9.1. Fonction de complexité = relation de récurrence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#c-n-fonction-de-c-n-1">
     1.9.2.
     <span class="math notranslate nohighlight">
      \(C(n)\)
     </span>
     fonction de
     <span class="math notranslate nohighlight">
      \(C(n-1)\)
     </span>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#c-n-fonction-de-c-n-2">
     1.9.3.
     <span class="math notranslate nohighlight">
      \(C(n)\)
     </span>
     fonction de
     <span class="math notranslate nohighlight">
      \(C(n/2)\)
     </span>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#star-star-autres-cas">
     1.9.4. (
     <span class="math notranslate nohighlight">
      \(\star\star\)
     </span>
     ) Autres cas
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#synthese">
   1.10. Synthèse
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#avoir-les-idees-claires">
     1.10.1. Avoir les idées claires
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#savoir-faire">
     1.10.2. Savoir-faire
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="complexites">
<span id="ch-complexite"></span><h1><span class="section-number">1. </span>Complexités<a class="headerlink" href="#complexites" title="Permalink to this headline">#</a></h1>
<p>Mis à jour : Jan 18, 2023, lecture : 20
minutes minimum, PhL.</p>
<p>Chapitre qui définit les notions de base de complexité algorithmique.
Des exemples d’analyse de complexité en temps ou en espace sont présentés sur des algorithmes itératifs simples.
Et ce sera l’occasion pour introduire l’algorithme de recherche par dichotomie dans un ensemble trié.</p>
<section id="motivations">
<h2><span class="section-number">1.1. </span>Motivations<a class="headerlink" href="#motivations" title="Permalink to this headline">#</a></h2>
<p><strong>Le contexte</strong></p>
<ol class="simple">
<li><p>un <em>problème</em></p></li>
<li><p>un <em>algorithme</em> qui calcule une/la solution</p></li>
<li><p>la solution dépend de certains <em>paramètres</em> du problème</p></li>
<li><p>un choix de ces paramètres <span class="math notranslate nohighlight">\(\to\)</span>  une <em>instance</em> du problème.</p></li>
</ol>
<p><strong>Les questions du jour</strong></p>
<ul class="simple">
<li><p>Combien de temps prend l’algorithme pour calculer cette solution ?</p></li>
<li><p>Combien d’espace-mémoire l’algorithme utilise pour calculer cette solution ?</p></li>
</ul>
<p>Autrement dit, quels sont <strong>les coûts en temps et en espace</strong> de la résolution avec <em>cet</em> algorithme ?</p>
<p>Première remarque de bon sens : ces coûts ne sont pas constants pour un problème donnée.
Ils dépendent <strong>de certains paramètres</strong> de l’<em>instance</em> du problème.</p>
</section>
<section id="exemples-introductifs">
<h2><span class="section-number">1.2. </span>Exemples introductifs<a class="headerlink" href="#exemples-introductifs" title="Permalink to this headline">#</a></h2>
<section id="pb1-calculer-la-somme-de-n-entiers">
<h3><span class="section-number">1.2.1. </span>Pb1 : calculer la somme de <span class="math notranslate nohighlight">\(n\)</span> entiers<a class="headerlink" href="#pb1-calculer-la-somme-de-n-entiers" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Le problème : calculer la somme de <span class="math notranslate nohighlight">\(n\)</span> valeurs entières</p></li>
<li><p>Une instance : un choix du nombre de valeurs <span class="math notranslate nohighlight">\(n\)</span> et ces <span class="math notranslate nohighlight">\(n\)</span> valeurs</p></li>
</ul>
<p>On suppose que ces <span class="math notranslate nohighlight">\(n\)</span> valeurs sont stockées dans un tableau <code class="docutils literal notranslate"><span class="pre">t:</span> <span class="pre">list[int]</span></code>.</p>
<p>Principe d’un algorithme :</p>
<ul class="simple">
<li><p>je parcours le tableau du début à la fin,</p></li>
<li><p>je lis chaque valeur et je l’accumule dans une variable initialement mise
à zéro</p></li>
<li><p>je retourne cette variable.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sommer</span><span class="p">(</span><span class="n">t</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dim_t</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;somme itérative de n=dim_t valeurs entières stockées dans un tableau t </span>
<span class="sd">    entrées. t tab d&#39;int de longueur dim_t. </span>
<span class="sd">    retourne res.&#39;&#39;&#39;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans res</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_t</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="pb2-recherche-de-l-indice-d-une-valeur-parmi-n-stockees-dans-un-tableau">
<h3><span class="section-number">1.2.2. </span>Pb2 : recherche de l’indice d’une valeur parmi <span class="math notranslate nohighlight">\(n\)</span> stockées dans un tableau<a class="headerlink" href="#pb2-recherche-de-l-indice-d-une-valeur-parmi-n-stockees-dans-un-tableau" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Le problème : recherche l’indice d’une valeur parmi <span class="math notranslate nohighlight">\(n\)</span> valeurs stockées dans un tableau[^rmq:indice]</p></li>
<li><p>Une instance : un choix de la valeur cherchée, du nombre <span class="math notranslate nohighlight">\(n\)</span>  de valeurs et de ces <span class="math notranslate nohighlight">\(n\)</span> valeurs du tableau <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p>Principe d’un algorithme :</p>
<ul>
<li><p>je parcours le tableau à partir de son premier indice,</p></li>
<li><p>je compare chaque valeur du tableau à la valeur cherchée,</p>
<ul>
<li><p>si égalité je retourne l’indice de cette valeur,</p></li>
<li><p>sinon je répète ce traitement sur la valeur suivante.</p></li>
</ul>
</li>
<li><p>Je renvoie un indice significatif de l’absence si aucune égalité n’a été satisfaite après le dernier indice du tableau.</p></li>
</ul>
</li>
</ul>
<p>[^rmq:indice] Le cas où il faudrait choisir entre plusieurs indices d’une valeur répétée n’est pas détaillé.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rechercheIterative</span><span class="p">(</span><span class="n">val</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">t</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">dim_t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;recherche itérative de val dans t tableau de taille dim_t </span>
<span class="sd">    retourne l&#39;indice de la première occurrence de val ou -1 si absence&#39;&#39;&#39;</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans res</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dim_t</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="premiere-analyse-empirique-des-complexites-en-temps-et-en-espace">
<h3><span class="section-number">1.2.3. </span>Première analyse empirique des complexités en temps et en espace<a class="headerlink" href="#premiere-analyse-empirique-des-complexites-en-temps-et-en-espace" title="Permalink to this headline">#</a></h3>
<section id="complexite-en-temps">
<h4>Complexité en temps<a class="headerlink" href="#complexite-en-temps" title="Permalink to this headline">#</a></h4>
<p>Coût en temps nécessaire à la résolution de Pb1 par <code class="docutils literal notranslate"><span class="pre">sommer(</span> <span class="pre">)</span></code> ?<br />
Coût en temps nécessaire à la résolution de Pb2 par <code class="docutils literal notranslate"><span class="pre">rechercheIterative(</span> <span class="pre">)</span></code> ?</p>
<p><strong>Pb1 et <code class="docutils literal notranslate"><span class="pre">sommer(</span> <span class="pre">)</span></code></strong></p>
<ul class="simple">
<li><p>le temps de résolution <strong>dépend de <span class="math notranslate nohighlight">\(n\)</span></strong> : le nombre de valeurs à sommer</p>
<ul>
<li><p>mais ne dépend <strong>pas</strong> de ces valeurs</p></li>
</ul>
</li>
<li><p>ce temps de calcul est une fonction croissante de <span class="math notranslate nohighlight">\(n\)</span></p>
<ul>
<li><p>OK mais croissante comment ? linéaire ? quadratique ?  logarithmique ?</p></li>
</ul>
</li>
</ul>
<p><strong>Pb2 et <code class="docutils literal notranslate"><span class="pre">rechercheIterative()</span></code></strong></p>
<ul class="simple">
<li><p>le temps de résolution <strong>dépend de <span class="math notranslate nohighlight">\(n\)</span>, de t, de val</strong> : le nombre de valeurs, de leur ordre et de la valeur à trouver</p></li>
<li><p><em>meilleur cas</em> : <code class="docutils literal notranslate"><span class="pre">val</span></code> est à l’indice 0 et coût indépendant de <span class="math notranslate nohighlight">\(n\)</span></p></li>
<li><p><em>pire cas</em> : <code class="docutils literal notranslate"><span class="pre">val</span></code> est absente de <code class="docutils literal notranslate"><span class="pre">t</span></code> et coût fonction croissante de <span class="math notranslate nohighlight">\(n\)</span></p></li>
</ul>
<p>Conclusions : les <strong>complexité en temps</strong> de ces 2 problèmes aux entrées très similaires dépendent de <strong>paramètres</strong> différents. La complexité en temps de la résolution de Pb2 n’est pas constante, même pour une valeur de <span class="math notranslate nohighlight">\(n\)</span> fixée. Elle dépend de <em>l’instance</em> du problème de recherche à résoudre. De façon imagée, Pb2 “dépend plus” de l’instance du problème que Pb1. Parmi les instances du Pb2, il faudra distinguer  celles qui conduisent à des <strong>pires cas</strong> pour le coût en temps, et inversement à des <strong>meilleurs cas</strong>.</p>
</section>
<section id="complexite-en-espace">
<h4>Complexité en espace<a class="headerlink" href="#complexite-en-espace" title="Permalink to this headline">#</a></h4>
<p>Coût en espace-mémoire en temps nécessaire à la résolution de Pb1 par <code class="docutils literal notranslate"><span class="pre">sommer(</span> <span class="pre">)</span></code> ?<br />
Coût en espace-mémoire temps nécessaire à la résolution de Pb2 par <code class="docutils literal notranslate"><span class="pre">rechercheIterative(</span> <span class="pre">)</span></code> ?</p>
<ul class="simple">
<li><p>ça <strong>dépend</strong> aussi <strong>de n</strong> : il faut déjà stocker les <span class="math notranslate nohighlight">\(n\)</span> valeurs de Pb1 et Pb2 !</p>
<ul>
<li><p>OK mais quel est l’espace mémoire <strong>supplémentaire pour résoudre</strong> le problème ?</p></li>
<li><p>Dépendant ou indépendant de <span class="math notranslate nohighlight">\(n\)</span> ? dépendant comment ?</p></li>
</ul>
</li>
</ul>
</section>
</section>
</section>
<section id="complexite-f-taille">
<h2><span class="section-number">1.3. </span>complexité = f(taille)<a class="headerlink" href="#complexite-f-taille" title="Permalink to this headline">#</a></h2>
<p>Il ressort de l’analyse empirique précédente que ces complexités sont des fonctions croissantes d’<strong>un paramètre significatif de la taille du problème</strong>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Etape 1 : quel paramètre de la fonction de complexité ?</strong></p>
<p>Identifier ce paramètre est l’étape 1 d’une analyse de complexité.</p>
</div>
<p><strong>Exemples.</strong></p>
<ul class="simple">
<li><p>calculer la somme de <span class="math notranslate nohighlight">\(n\)</span> valeurs entières</p>
<ul>
<li><p>on va chercher une fonction <span class="math notranslate nohighlight">\(C(n)\)</span> où <span class="math notranslate nohighlight">\(n\)</span> est le nombre de valeurs à sommer.</p></li>
</ul>
</li>
<li><p>calculer l’addition de 2 nombres entiers</p>
<ul>
<li><p>on va chercher une fonction <span class="math notranslate nohighlight">\(C(n)\)</span> où <span class="math notranslate nohighlight">\(n\)</span> est le nombre de chiffres maximal des 2 opérandes</p></li>
</ul>
</li>
<li><p>rechercher l’indice d’une valeur dans (un tableau <code class="docutils literal notranslate"><span class="pre">t</span></code> de) <span class="math notranslate nohighlight">\(n\)</span> valeurs entières</p>
<ul>
<li><p>on va chercher une fonction <span class="math notranslate nohighlight">\(C(n)\)</span> où <span class="math notranslate nohighlight">\(n\)</span> est le nombre de valeurs, <em>ie.</em> <code class="docutils literal notranslate"><span class="pre">lent(t)</span></code></p></li>
</ul>
</li>
<li><p>trier une liste de <span class="math notranslate nohighlight">\(n\)</span> valeurs (stockées dans un tableau <code class="docutils literal notranslate"><span class="pre">t</span></code>)</p>
<ul>
<li><p>on va chercher une fonction <span class="math notranslate nohighlight">\(C(n)\)</span> où <span class="math notranslate nohighlight">\(n\)</span> est le nombre de valeurs, <em>ie.</em> <code class="docutils literal notranslate"><span class="pre">lent(t)</span></code></p></li>
</ul>
</li>
<li><p>rechercher l’indice d’une valeur dans un tableau <strong>trié</strong> <code class="docutils literal notranslate"><span class="pre">t</span></code> de <span class="math notranslate nohighlight">\(n\)</span> valeurs entières</p>
<ul>
<li><p>on va chercher une fonction <span class="math notranslate nohighlight">\(C(n)\)</span> où <span class="math notranslate nohighlight">\(n\)</span> est le nombre de valeurs, <em>ie.</em> <code class="docutils literal notranslate"><span class="pre">lent(t)</span></code></p></li>
</ul>
</li>
</ul>
<section id="objectifs-d-une-analyse-de-complexite-en-temps">
<h3><span class="section-number">1.3.1. </span>Objectifs d’une analyse de complexité en temps<a class="headerlink" href="#objectifs-d-une-analyse-de-complexite-en-temps" title="Permalink to this headline">#</a></h3>
<p>Il s’agit maintenant d’exprimer cette fonction <span class="math notranslate nohighlight">\(C(n)\)</span>.
C-a-d. <strong>comment mesurer ce coût ?</strong></p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Que cherche-t-on avec une analyse de complexité ?</p>
<p>On cherche surtout à <strong>dégager des tendances</strong> avec cette fonction de complexité <span class="math notranslate nohighlight">\(C(n)\)</span>.<br />
L’objectif est d’<strong>estimer</strong> le coût théorique de la résolution du problème,
<em>ie.</em> l’<strong>ordre de grandeur</strong> de cette fonction de la taille du problème.</p>
</div>
</section>
<section id="un-modele-de-calcul-pour-la-complexite-en-temps">
<h3><span class="section-number">1.3.2. </span>Un modèle de calcul pour la complexité en temps<a class="headerlink" href="#un-modele-de-calcul-pour-la-complexite-en-temps" title="Permalink to this headline">#</a></h3>
<p>Le mode d’exécution réel d’un programme sur un ordinateur actuel est trop compliqué pour justifier la recherche d’un décompte précis de ce coût en temps et en mémoire. On verra aussi que la mesure même des temps d’exécution réels est moins facile qu’il n’y parait.</p>
<p>L’analyse de complexité s’effectue à partir d’un <strong>modèle de calcul</strong> : on exécute l’algorithme sur un modèle de machine simple (beaucoup de détails d’une véritable exécution sont ignorés) mais pas trop simpliste (les résultats et les observations réelles sont raisonnablement corrélées).</p>
<p><strong>Toutes les instructions</strong> importantes comptent <strong>1 unité</strong> de temps</p>
<ul class="simple">
<li><p>1 = affectation = comparaison = opération arithmétique =  opération logique = accès mémoire = entrées/sorties</p></li>
</ul>
<p><strong>Les instructions s’exécutent séquentiellement</strong></p>
<ul class="simple">
<li><p>si l’instruction p coûte c1 et l’instruction q coûte c2 alors la suite d’instructions p, q coûte c1+c2</p></li>
</ul>
<p><strong>Coût de la répétition <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">_</span> <span class="pre">in</span> <span class="pre">range(n):</span> <span class="pre">...</span></code></strong></p>
<ul class="simple">
<li><p>si le coût du corps de boucle ne dépend pas de i : n x coût(corps_de_boucle)</p></li>
<li><p>sinon : la somme des coûts de chacune des n répétitions</p></li>
</ul>
<p><strong>Coût de la répétition <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">...:</span> <span class="pre">...</span></code></strong></p>
<ul class="simple">
<li><p>dépend du nombre de répétitions, inconnu a priori</p></li>
<li><p>on peut <strong>majorer</strong> ce nombre de répétitions</p></li>
</ul>
<p><strong>Coût du branchement conditionnel <code class="docutils literal notranslate"><span class="pre">if...</span> <span class="pre">elif...</span> <span class="pre">else...</span></code></strong></p>
<ul class="simple">
<li><p>inférieur ou égal au coût maximum de chaque branche d’instructions</p></li>
</ul>
</section>
<section id="application-au-pb1">
<h3><span class="section-number">1.3.3. </span>Application au Pb1<a class="headerlink" href="#application-au-pb1" title="Permalink to this headline">#</a></h3>
<p>Pb1 : calculer la somme de n valeurs entières avec la somme itérative avec accumulation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">sommer</span><span class="p">(</span><span class="n">t</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dim_t</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">2</span>    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans res</span>
<span class="linenos">3</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_t</span><span class="p">):</span>
<span class="hll"><span class="linenos">4</span>        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    
</span><span class="linenos">5</span>    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
<ul class="simple">
<li><p>une boucle <code class="docutils literal notranslate"><span class="pre">for</span></code></p></li>
<li><p>pas de test <code class="docutils literal notranslate"><span class="pre">if</span></code></p></li>
<li><p>additions entières, affectations d’entiers, accès (lecture) éléments d’un tableau,
retour, contrôle de boucle <code class="docutils literal notranslate"><span class="pre">for</span></code></p></li>
</ul>
<p><strong>Que compter ? Où-le compter?</strong></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Etape 2 : quelles instructions sont significatives du coût du traitement ?</strong></p>
<p>La fonction de complexité compte le nombre d’exécution de ces instructions significative du traitement.</p>
</div>
<ul class="simple">
<li><p>Il est inutile de compter toutes les instructions de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code></p></li>
<li><p>on simplifie le décompte en <em>identifiant certaines instructions significatives</em> du temps de traitement.</p></li>
<li><p>on réduit au maximum ce nombre d’instructions significatives : on verra qu’on n’est pas à un facteur multiplicatif près (ordre de grandeur)</p></li>
</ul>
<p>Ici on <strong>compte</strong> seulement <strong>les additions de la ligne 4</strong> dans <code class="docutils literal notranslate"><span class="pre">sommer()</span></code></p>
<ul>
<li><p>on a autant d’affectations dans <code class="docutils literal notranslate"><span class="pre">res</span></code> que d’additions</p></li>
<li><p>on ne compte pas ces affectations,</p></li>
<li><p>ni les traitements cachées dans <em>le contrôle</em> de la boucle <code class="docutils literal notranslate"><span class="pre">for</span></code> (voir <a class="reference internal" href="#rmq-controle"><span class="std std-ref">remarque</span></a>)</p></li>
<li><p>écart : un facteur multiplicatif du nombre d’additions comptées</p></li>
<li><p>conclusion :</p>
<blockquote>
<div><p>complexité(<code class="docutils literal notranslate"><span class="pre">sommer()</span></code>) = f(nombre d’additions du corps de boucle)</p>
</div></blockquote>
</li>
</ul>
<p>Décompte : <code class="docutils literal notranslate"><span class="pre">sommer()</span></code> effectue 1 addition (L4) à chacune des n répétitions de la boucle pour (L3-4)</p>
<blockquote>
<div><p><strong>C(n) = n</strong></p>
</div></blockquote>
<p>L’algorithme itératif <code class="docutils literal notranslate"><span class="pre">sommer</span></code> a une <strong>complexité linéaire en la taille <span class="math notranslate nohighlight">\(n\)</span></strong> du problème à résoudre.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Quelle interprétation ?</p>
<p>Si on double le nombre de valeurs à sommer, on double le temps de calcul</p>
<p>C’est d’autant plus vrai que n est assez grand pour que le temps de ces
opérations (les additions) constitue <em>la part significative</em> du temps
total de l’exécution de sommer.</p>
</div>
<p><strong>Remarque.</strong> La complexité linéaire de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code>  ne dépend pas des valeurs sommées, juste de leur nombre.</p>
</section>
<section id="du-modele-pour-l-algorithme-a-la-mesure-du-temps-d-execution-d-un-programme">
<h3><span class="section-number">1.3.4. </span>Du modèle pour l’algorithme à la mesure du temps d’exécution d’un programme<a class="headerlink" href="#du-modele-pour-l-algorithme-a-la-mesure-du-temps-d-execution-d-un-programme" title="Permalink to this headline">#</a></h3>
<p>On conclue cette première analyse en montrant que l’analyse précédente est significative du temps réel d’exécution  de la fonction <code class="docutils literal notranslate"><span class="pre">sommer()</span></code>.</p>
<p>Pourtant :</p>
<ul class="simple">
<li><p>Des différences importantes entre le modèle d’analyse de complexité de l’algorithme et la chaîne actuelle de calcul : processeur, mémoires hiérarchiques, options du compilateur, parallélisme, prédiction …</p></li>
<li><p>La mesure des performances d’un code est un processus expérimental difficile à mettre en oeuvre de façon fiable et qui trompe facilement</p>
<ul>
<li><p>Expérience dans le cours de programmation</p></li>
</ul>
</li>
<li><p>Exemple pour des algorithmes très calculatoires</p>
<ul>
<li><p>on compte le nombre d’opérations arithmétiques</p></li>
<li><p>on mesure les temps d’exécution d’un programme (python sur mac-intel)</p></li>
</ul>
</li>
</ul>
<p>Mesures sur ma machine de la somme codée en C :</p>
<p><img alt="mesures sommer" src="../_images/complexite_sommer.png" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sommer</span></code> est bien <em>linéaire</em> en nombre d’additions</p></li>
<li><p>quel sur-coût observer quand la taille du problème est multipliée par 10 ?</p></li>
</ul>
</section>
<section id="application-au-pb-2">
<h3><span class="section-number">1.3.5. </span>Application au Pb 2<a class="headerlink" href="#application-au-pb-2" title="Permalink to this headline">#</a></h3>
<p>Le traitement <code class="docutils literal notranslate"><span class="pre">rechercheIterative()</span></code> est, dans un premier temps, similaire à celui de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">rechercheIterative</span><span class="p">(</span><span class="n">val</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">t</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">dim_t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">2</span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans res</span>
<span class="linenos">3</span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dim_t</span><span class="p">:</span>
<span class="hll"><span class="linenos">4</span>        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span><span class="linenos">5</span>            <span class="k">return</span> <span class="n">i</span>
<span class="linenos">6</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="linenos">7</span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<ul class="simple">
<li><p>paramètre de complexité : le nombre de valeurs <code class="docutils literal notranslate"><span class="pre">dim_t</span></code> ou plus simplement <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p>instruction significative  : ligne 4</p></li>
<li><p>mesure de complexité en temps : nombre de comparaisons de cette ligne 4</p></li>
</ul>
<p>On cherche une fonction de complexité <span class="math notranslate nohighlight">\(C(n)\)</span>.</p>
<ul class="simple">
<li><p>La répétition est effectuée avec une boucle <code class="docutils literal notranslate"><span class="pre">while</span></code></p></li>
<li><p>Le nombre de répétition ne peut être que <strong>majoré</strong></p>
<ul>
<li><p>il dépend aussi de la valeur cherchée <code class="docutils literal notranslate"><span class="pre">val</span></code> et de l’ordre des valeurs dans le tableau <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p>il y a des meilleurs cas et des pire cas</p></li>
</ul>
</li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Majoration dans le pire cas</p>
<p>On s’intéresse au coût dans le pire cas qui fournit une <strong>majoration</strong> du coût de toutes les
exécutions possibles, <em>ie.</em> le pire coût de résolution de toutes les instances du problème Pb2 pour un nombre <code class="docutils literal notranslate"><span class="pre">n</span></code> de valeurs fixé.</p>
</div>
<p>On peut écrire ici :</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(C(n) \le n\)</span></p>
</div></blockquote>
</section>
<section id="conclusions-de-ces-deux-analyses-de-complexites-en-temps">
<h3><span class="section-number">1.3.6. </span>Conclusions de ces deux analyses de complexités en temps<a class="headerlink" href="#conclusions-de-ces-deux-analyses-de-complexites-en-temps" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>La complexité en temps de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code> est linéaire en le nombre de valeurs à sommer.</p>
<ul>
<li><p>Elle ne dépend pas des valeurs sommées, juste de leur nombre.</p></li>
</ul>
</li>
<li><p>La complexité en temps de <code class="docutils literal notranslate"><span class="pre">rechercheIterative()</span></code> est au pire linéaire en le nombre de valeurs dans lequel la recherche est effectuée.</p>
<ul>
<li><p>A la différence de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code>, cette complexité dépend de <code class="docutils literal notranslate"><span class="pre">n</span></code> et aussi d’autres paramètres de l’instance du problème</p></li>
<li><p>dans le meilleur cas, le nombre de comparaisons de la ligne 4 est <em>constant</em> par rapport à <code class="docutils literal notranslate"><span class="pre">n</span></code> et <em>égal</em> à 1 – c’est mieux que <code class="docutils literal notranslate"><span class="pre">sommer()</span></code> !</p></li>
<li><p>dans le pire cas, le nombre de comparaisons de la ligne 4 est <em>égal</em> à <code class="docutils literal notranslate"><span class="pre">n</span></code> – c’est identique à <code class="docutils literal notranslate"><span class="pre">sommer()</span></code>.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="id1">
<h2><span class="section-number">1.4. </span>Complexité en espace<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Quelle quantité d’espace-mémoire est nécessaire pour que l’algorithme trouve la solution du problème ?</p>
<ul>
<li><p>On cherche encore une fonction croissante d’un paramètre significatif de la taille du problème</p></li>
</ul>
</li>
<li><p><strong>Quel espace-mémoire mesurer ?</strong></p>
<ul>
<li><p>on ne compte pas la place des données d’entrée, ni des résultats : incompressible quelque soit l’algorithme</p></li>
<li><p>on compte uniquement <strong>la place mémoire supplémentaire</strong> nécessaire à la résolution</p></li>
</ul>
</li>
<li><p>Cas facile / moyen / un peu difficile :</p>
<ul>
<li><p>facile = statique : toutes les variables utilisées sont connues dans le code-source</p>
<ul>
<li><p>on compte leur encombrement en mémoire selon leurs types : scalaire, tableau 1D, 2D …</p></li>
</ul>
</li>
<li><p>moyen = dynamique</p>
<ul>
<li><p>la résolution utilise de l’allocation dynamique de mémoire, eg. les <code class="docutils literal notranslate"><span class="pre">list</span></code> python</p></li>
<li><p>une analyse plus technique est nécessaire</p></li>
</ul>
</li>
<li><p>un peu difficile = appels récursifs</p>
<ul>
<li><p>l’algorithme est récursif … à venir très bientôt, étude regroupée en fin de ce chapitre</p></li>
<li><p>la complexité en espace-mémoire peut alors être très, voire trop importante</p></li>
<li><p>l’analyse s’appuie sur des expressions récurrentes</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<section id="exemple-avec-pb1">
<h3><span class="section-number">1.4.1. </span>Exemple avec Pb1<a class="headerlink" href="#exemple-avec-pb1" title="Permalink to this headline">#</a></h3>
<p>Complexité en espace-mémoire de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code>?</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="linenos">1</span><span class="k">def</span> <span class="nf">sommer</span><span class="p">(</span><span class="n">t</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dim_t</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span class="linenos">2</span>    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans res</span>
<span class="linenos">3</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_t</span><span class="p">):</span>
<span class="hll"><span class="linenos">4</span>        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    
</span><span class="hll"><span class="linenos">5</span>    <span class="k">return</span> <span class="n">res</span>
</span></pre></div>
</div>
<p><strong>Analyse :</strong></p>
<ul class="simple">
<li><p>ligne 1 : on ne compte pas les <code class="docutils literal notranslate"><span class="pre">n</span></code> places-mémoire pour l’entrée : le tableau d’entiers <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p>lignes 2 et 5 : on ne compte pas la place mémoire pour le résultat retourné <code class="docutils literal notranslate"><span class="pre">res</span></code></p></li>
<li><p>il suffit de pouvoir stocker l’accumulation des <code class="docutils literal notranslate"><span class="pre">t[i]</span></code> avec et dans <code class="docutils literal notranslate"><span class="pre">res</span></code></p></li>
<li><p><strong>au plus un seul entier suffit</strong> (selon que l’accumulation s’effectue en place ou non) et ce <strong>quelque soit la taille du problème !</strong></p></li>
<li><p>on oublie encore le contrôle de la boucle <code class="docutils literal notranslate"><span class="pre">for</span></code> qui nécessite la place mémoire pour <code class="docutils literal notranslate"><span class="pre">i</span></code> au moins.</p></li>
</ul>
<p><strong>Conclusion :</strong> La complexité en espace-mémoire de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code> est constante.</p>
<p><strong>Remarque :</strong> c’est encore la ligne 4 qui est significative !</p>
</section>
</section>
<section id="un-autre-exemple-de-complexite-polynomiale-en-temps">
<h2><span class="section-number">1.5. </span>Un autre exemple de complexité polynomiale en temps<a class="headerlink" href="#un-autre-exemple-de-complexite-polynomiale-en-temps" title="Permalink to this headline">#</a></h2>
<p><strong>Vocabulaire important.</strong></p>
<ul class="simple">
<li><p>Par complexité <em>polynomiale</em>, on entend une fonction <span class="math notranslate nohighlight">\(C(n)\)</span>  qui est un polynôme en <span class="math notranslate nohighlight">\(n\)</span>.</p>
<ul>
<li><p>complexité linéaire, quadratique, cubique, …</p></li>
</ul>
</li>
<li><p>Le degré de ce polynôme donne  l’ordre de grandeur cherché</p></li>
</ul>
<section id="complexite-quadratique-du-produit-matrice-x-vecteur">
<span id="sec-prodmatvec"></span><h3><span class="section-number">1.5.1. </span>Complexité quadratique du produit matrice x vecteur<a class="headerlink" href="#complexite-quadratique-du-produit-matrice-x-vecteur" title="Permalink to this headline">#</a></h3>
<p>Pb : calculer le produit matrice x vecteur</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Au</span><span class="p">(</span><span class="n">A</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">nblA</span><span class="p">:</span> <span class="nb">int</span> <span class="p">,</span> <span class="n">nbcA</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">u</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">nblu</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39; calcule produit mat-vec pour : </span>
<span class="sd">    A matrice carrée de taille nblA x nbcA</span>
<span class="sd">    u : vecteur de taille nblu</span>
<span class="sd">    si nbcA == nblu retourne </span>
<span class="sd">    v: vecteur de taille nblA</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="n">nbcA</span> <span class="o">==</span> <span class="n">nblu</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblA</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans v[i]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbcA</span><span class="p">):</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">v</span>
</pre></div>
</div>
</div>
</div>
<p>Analyse simplifiée en fixant toutes les dimensions à <code class="docutils literal notranslate"><span class="pre">n</span></code>:</p>
<ul class="simple">
<li><p>appel pour <code class="docutils literal notranslate"><span class="pre">A[n][n],</span> <span class="pre">u[n]</span> <span class="pre">-&gt;</span> <span class="pre">v[n]</span></code></p></li>
<li><p>on simplifie l’écriture du code pour cet appel :</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nblA</span> <span class="pre">==</span> <span class="pre">nbcA</span> <span class="pre">==</span> <span class="pre">nblu</span> <span class="pre">==</span> <span class="pre">n</span></code></p></li>
</ul>
</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">Au</span><span class="p">(</span><span class="n">A</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">u</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="hll"><span class="linenos">2</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="linenos">3</span>        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans v[i]</span>
<span class="hll"><span class="linenos">4</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="hll"><span class="linenos">5</span>            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class="linenos">6</span>    <span class="k">return</span> <span class="n">v</span>
</pre></div>
</div>
<p>Exemple de décompte (presque) exhaustif des instructions :</p>
<p>Deux boucles <code class="docutils literal notranslate"><span class="pre">for</span></code> imbriquées de taille n chacune.</p>
<ul class="simple">
<li><p>boucle extérieure : n répétitions de</p>
<ul>
<li><p>ligne 3 : 1 affectation</p></li>
<li><p>ligne 4 : boucle intérieure : n répétitions de</p>
<ul>
<li><p>ligne 5 : 1 *, 1 +, 1 =</p></li>
<li><p><span class="math notranslate nohighlight">\(\to\)</span> total intérieur = 2n opérations arithm., n affectations</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Total</strong> extérieur-intérieur :</p>
<ul class="simple">
<li><p><strong>2n<span class="math notranslate nohighlight">\(^2\)</span></strong> opérations</p></li>
<li><p>n<span class="math notranslate nohighlight">\(^2\)</span> + n affectations</p></li>
</ul>
<p id="rmq-controle"><strong>Remarque.</strong>
Bien que détaillé, ce décompte basé sur les instructions d’affectations explicites n’est pas exhaustif en pratique. En effet, les construction <code class="docutils literal notranslate"><span class="pre">for</span></code> comportent implicitement des affectations, comparaisons et incrémentations qui n’ont pas été ajoutées au décompte total.</p>
<p>En pratique, la construction <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(n):</span></code> comporte</p>
<ul class="simple">
<li><p>1+n affectations,</p></li>
<li><p>n incrémentations,</p></li>
<li><p>n+1 comparaisons.</p></li>
</ul>
<p>Ces instructions représente <em>le contrôle de la boucle <code class="docutils literal notranslate"><span class="pre">for</span></code></em>.</p>
<p>Quel est l’effet de ce contrôle sur le décompte effectué pour les 2 boucles imbriquées ?  On vous laisse vous convaincre qu’il ne fait qu’augmenter les facteur multiplicatifs des expressions qui dépendent de <span class="math notranslate nohighlight">\(n\)</span>. Ce contrôle (même dans le cas imbriqué) n’impacte pas le <em>degré en <span class="math notranslate nohighlight">\(n\)</span> des expressions identifiées</em>. Lorsque <span class="math notranslate nohighlight">\(n\)</span> est arbitrairement grand, c-a-d. <span class="math notranslate nohighlight">\(n \rightarrow +\infty\)</span>, ces expressions varient comme leur terme de plus haut degré. Leur coefficient (lui impacté par le facteur multiplicatif) n’a aucun d’effet sur l’ordre de gradeur de l’expression, et à un effet secondaire sur la tendance.</p>
<p><strong>Asymptotiquement :</strong> pour <code class="docutils literal notranslate"><span class="pre">n</span></code> arbitrairement grand,</p>
<blockquote>
<div><p>C(Ax) <span class="math notranslate nohighlight">\(\sim\)</span> n<span class="math notranslate nohighlight">\(^2\)</span> : complexité <strong>quadratique</strong> en temps</p>
</div></blockquote>
<p>C’est cette <strong>tendance asymptotique</strong> qui nous intéresse. Ainsi, <em>un décompte simplifié aux instructions significatives de cette complexité asymptotique</em> est souvent suffisant pour nos études de complexité. Attention cependant de ne pas oublier, dans ce cas, qu’une telle complexité <em>cache des facteurs multiplicatifs</em> qui peuvent être importants pour des “petites” valeurs de <span class="math notranslate nohighlight">\(n\)</span>. Nous reviendrons sur cet aspect dans une <a class="reference internal" href="#sec-complexiteasymptotique"><span class="std std-ref">section prochaine</span></a>.</p>
<p><strong>Exercice.</strong> Effectuer une analyse de complexité à partir de l’expression mathématique du produite matrice x vecteur.</p>
</section>
<section id="mesures-du-temps-d-execution-du-produit-matrice-vecteur">
<h3><span class="section-number">1.5.2. </span>Mesures du temps d’exécution du produit matrice-vecteur<a class="headerlink" href="#mesures-du-temps-d-execution-du-produit-matrice-vecteur" title="Permalink to this headline">#</a></h3>
<figure class="align-default" id="fig-timingprodmatvec">
<a class="reference internal image-reference" href="../_images/complexiteProdMatVec.png"><img alt="../_images/complexiteProdMatVec.png" src="../_images/complexiteProdMatVec.png" style="height: 150mm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1.1 </span><span class="caption-text">Les mesures sont alignées sur une droite parallèle à celle <span class="math notranslate nohighlight">\(n^2\)</span> (une droite en échelle log-log).</span><a class="headerlink" href="#fig-timingprodmatvec" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>L’échelle log-log est adaptée au tracé de ce temps d’exécution quadratique en la taille : la taille prend des ordre de grandeurs différents. Ici de 10 à 10000.</p>
<ul class="simple">
<li><p>La pente vaut 2, ce qui représente :</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(10^1\)</span> sur x <span class="math notranslate nohighlight">\(\to\)</span> <span class="math notranslate nohighlight">\(10^2\)</span> sur y</p></li>
<li><p>soit donc x \to<span class="math notranslate nohighlight">\( \)</span>x^2$</p></li>
</ul>
</li>
<li><p>Attention : <span class="math notranslate nohighlight">\(\log_10\)</span> sur les axes des x et des y mais avec des échelles différentes ! (comparer la distance entre deux valeurs espacées d’un facteur 10).</p></li>
</ul>
<p>Ci-après une autre illustration où le temps de calcul normalisé par <span class="math notranslate nohighlight">\(n^2\)</span> est bien une droite horizontale.</p>
<p>Question : que représente la valeur indiquée par cette droite ?</p>
<figure class="align-default" id="fig-timingprodmatvec2">
<a class="reference internal image-reference" href="../_images/complexiteProdMatVec2.png"><img alt="../_images/complexiteProdMatVec2.png" src="../_images/complexiteProdMatVec2.png" style="height: 150mm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1.2 </span><span class="caption-text">Cette autre échelle log-log est explicite.</span><a class="headerlink" href="#fig-timingprodmatvec2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p><strong>Conseil :</strong> être à l’aise pour choisir le tracé le plus parlant !</p>
</section>
<section id="complexite-en-memoire-du-produit-matrice-x-vecteur">
<h3><span class="section-number">1.5.3. </span>Complexité en mémoire du produit matrice x vecteur<a class="headerlink" href="#complexite-en-memoire-du-produit-matrice-x-vecteur" title="Permalink to this headline">#</a></h3>
<p>Assez similaire à celle de <code class="docutils literal notranslate"><span class="pre">sommer()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">Au</span><span class="p">(</span><span class="n">A</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">u</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="hll"><span class="linenos">2</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="linenos">3</span>        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># j&#39;accumule dans v[i]</span>
<span class="hll"><span class="linenos">4</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class="hll"><span class="linenos">5</span>            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class="linenos">6</span>    <span class="k">return</span> <span class="n">v</span>
</pre></div>
</div>
<ol class="simple">
<li><p>données et résultats</p></li>
</ol>
<ul class="simple">
<li><p>entrée : <code class="docutils literal notranslate"><span class="pre">A[n][n],</span> <span class="pre">u[n]</span></code> <span class="math notranslate nohighlight">\(\to\)</span>  n<span class="math notranslate nohighlight">\(^2\)</span> + n</p></li>
<li><p>résultat : <code class="docutils literal notranslate"><span class="pre">v[n]</span></code> <span class="math notranslate nohighlight">\(\to\)</span> n</p></li>
</ul>
<p>Un espace mémoire de n<span class="math notranslate nohighlight">\(^2\)</span> + n unités-mémoire est minimal (sauf matrice ou vecteur
particulier)</p>
<ol class="simple">
<li><p>algorithme</p></li>
</ol>
<ul class="simple">
<li><p>ligne 5 : mise à jour de chaque composante :</p>
<ul>
<li><p>une  variable intermédiaire : résultat de la <code class="docutils literal notranslate"><span class="pre">*</span></code> si l’accumulation <code class="docutils literal notranslate"><span class="pre">+</span></code> effectuée <em>en place</em> (aucun espace-mémoire nécessaire)</p></li>
<li><p>ou deux variables intermédiaires si l’accumulation <code class="docutils literal notranslate"><span class="pre">+</span></code> non “en place”.</p></li>
</ul>
</li>
<li><p>Conclusion : espace mémoire supplémentaire <strong>constant quelque soit n</strong>.</p></li>
</ul>
</section>
</section>
<section id="complexite-et-log-2">
<h2><span class="section-number">1.6. </span>Complexité et <span class="math notranslate nohighlight">\(\log_2\)</span><a class="headerlink" href="#complexite-et-log-2" title="Permalink to this headline">#</a></h2>
<div class="admonition-remarque-motivante admonition">
<p class="admonition-title">Remarque motivante</p>
<p>La fonction <span class="math notranslate nohighlight">\(\log_2(x)\)</span> croît <strong>beaucoup</strong> moins vite que toute fonction polynomiale en <span class="math notranslate nohighlight">\(x\)</span> : <span class="math notranslate nohighlight">\(x, x^2, x^3, \dots\)</span> – et même que toute fonction à puissance rationnelle en <span class="math notranslate nohighlight">\(x\)</span> : <span class="math notranslate nohighlight">\(\sqrt x, x^{1/3}, \dots\)</span></p>
</div>
<section id="pas-que-des-puissances-entieres-de-la-taille-du-pb">
<h3><span class="section-number">1.6.1. </span>Pas que des puissances entières de la taille du pb<a class="headerlink" href="#pas-que-des-puissances-entieres-de-la-taille-du-pb" title="Permalink to this headline">#</a></h3>
<p><strong>Exemple de référence à connaître  : algorithmes de recherche</strong></p>
<p>Le problème : rechercher si une valeur est présente au non dans un tableau de n valeurs</p>
<ul>
<li><p>mesure de complexité : nombre de comparaisons</p></li>
<li><p>paramètre de cette complexité : <code class="docutils literal notranslate"><span class="pre">n</span></code> le nombre de valeurs dans le tableau</p></li>
<li><p>déjà vu : un algorithme de <strong>complexité linéaire</strong> : recherche séquentielle (itérative)</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(C(n) = n\)</span> dans le pire cas</p>
</div></blockquote>
</li>
</ul>
<p>Un problème proche : rechercher si une valeur est présente au non dans un
tableau de n valeurs <strong>triées</strong></p>
<ul class="simple">
<li><p>mesure de complexité : nombre de comparaisons</p></li>
<li><p>paramètre de cette complexité : <code class="docutils literal notranslate"><span class="pre">n</span></code> le nombre de valeurs dans le tableau</p></li>
<li><p><strong>nouveau :</strong> un algorithme de <strong>complexité logarithmique</strong> : recherche dichotomique</p></li>
</ul>
<p>Principe de l’algorithme de recherche par dichotomie <strong>dans un tableau trié</strong> :</p>
<ul class="simple">
<li><p>Je partage le tableau en 2 et je compare la valeur du milieu avec la valeur cherchée.</p></li>
<li><p>Selon le résultat de la comparaison, je jette la moitié droite ou gauche du tableau.</p></li>
<li><p>Je <strong>recommence</strong> sur ce tableau de <strong>taille moitié</strong> : partage en 2, comparaison milieu, abandon éventuel d’une moitié,</p>
<ul>
<li><p>jusqu’à avoir trouvé la valeur et là, je m’arrête</p></li>
<li><p>OU obtenir un (sous-)tableau réduit à 0 ou 1 élément et là, je m’arrête aussi … peut-être sans l’avoir trouvé.</p></li>
</ul>
</li>
</ul>
<p>Analyse :</p>
<ul class="simple">
<li><p><strong>Nombre de comparaisons = nombre de découpages en 2</strong> du tableau de longueur n</p></li>
<li><p>Nombre <strong>maximal</strong> de comparaisons = nombre de découpages en 2 “de n valeurs” jusqu’à l’arrêt “avec absence” : le <em>pire cas</em> = <span class="math notranslate nohighlight">\(\lceil \log_2(n) \rceil\)</span></p></li>
</ul>
<div class="admonition-expliquer-ce-log-2-n admonition">
<p class="admonition-title">Expliquer ce <span class="math notranslate nohighlight">\(\log_2(n)\)</span></p>
<p>Un peu de maths pour compter ce nombre de divisions par 2 :</p>
<ul class="simple">
<li><p>question : combien de découpages par 2 de <span class="math notranslate nohighlight">\(n\)</span> valeurs jusqu’à en obtenir 1 seule ?</p></li>
<li><p>réponse : <span class="math notranslate nohighlight">\(\lceil \log_2(n) \rceil\)</span> ou plus simplement <strong><span class="math notranslate nohighlight">\(\log_2(n)\)</span></strong> si <span class="math notranslate nohighlight">\(n\)</span> est une puissance de 2.</p></li>
<li><p>comprendre le principe de la réponse : <strong>partons de <span class="math notranslate nohighlight">\(n = 2^p = n_0\)</span></strong></p>
<ul>
<li><p>on divise <span class="math notranslate nohighlight">\(n_0\)</span> par 2 <span class="math notranslate nohighlight">\(\to\)</span> il reste <span class="math notranslate nohighlight">\(n_1 = n_0/2 = 2^{p-1}\)</span> valeurs</p></li>
<li><p>on divise <span class="math notranslate nohighlight">\(n_1\)</span> par 2 <span class="math notranslate nohighlight">\(\to\)</span> il reste <span class="math notranslate nohighlight">\(n_2 = n_1/2 = 2^{p-2}\)</span> valeurs</p></li>
<li><p><span class="math notranslate nohighlight">\(\dots\)</span></p></li>
<li><p>on divise <span class="math notranslate nohighlight">\(n_{k-1}\)</span> par 2 <span class="math notranslate nohighlight">\(\to\)</span> il reste <span class="math notranslate nohighlight">\(n_k = n_{k-1}/2 = 2^{p-k}\)</span> valeurs</p></li>
<li><p>on veut trouver <span class="math notranslate nohighlight">\(k\)</span> tel que <span class="math notranslate nohighlight">\(2^{p-k} = 2^0 = 1\)</span> valeur</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(k = p\)</span> convient</p></li>
<li><p>il faut donc <span class="math notranslate nohighlight">\(p\)</span> divisions par 2 de <span class="math notranslate nohighlight">\(n = 2^p\)</span></p></li>
<li><p>et <span class="math notranslate nohighlight">\(p = \log_2(2^p) = \log_2(n)\)</span>.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>En partant d’une puissance de 2, on exhibe facilement <span class="math notranslate nohighlight">\(\log_2(n)\)</span>.</p></li>
<li><p>Pour un autre <span class="math notranslate nohighlight">\(n\)</span> quelconque, on majorera par la puissance de 2 immédiatement supérieure (les notations <span class="math notranslate nohighlight">\(\lfloor ~ \rfloor\)</span> et <span class="math notranslate nohighlight">\(\lceil ~ \rceil\)</span> sont commodes pour ces cas).</p></li>
</ul>
</div>
<p>Pour cette analyse en tendance, on conserve le nombre plus simple <span class="math notranslate nohighlight">\(\log_2(n)\)</span>.</p>
<p>Résultat : la complexité en temps de la recherche dichotomique est</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(C(n) = \log_2(n)\)</span> <strong>dans le pire cas</strong>.</p>
</div></blockquote>
<p><strong>Conclusion.</strong></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:left head"><p>Algorithme</p></th>
<th class="text-align:left head"><p>Hypothèse</p></th>
<th class="text-align:center head"><p>Complexité en temps</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:left"><p>Recherche séquentielle</p></td>
<td class="text-align:left"><p>aucune</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(C(n) = n\)</span> dans le pire cas</p></td>
</tr>
<tr class="row-odd"><td class="text-align:left"><p>Recherche dichotomique</p></td>
<td class="text-align:left"><p>valeurs triées</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(C(n) = \log_2(n)\)</span> dans le pire cas</p></td>
</tr>
</tbody>
</table>
</section>
<section id="reduire-la-complexite-diviser-pour-regner">
<h3><span class="section-number">1.6.2. </span>Réduire la complexité ? Diviser pour régner !<a class="headerlink" href="#reduire-la-complexite-diviser-pour-regner" title="Permalink to this headline">#</a></h3>
<p>La recherche dichotomique est un exemple d’algorithme de <em>complexité logarithmique</em></p>
<p>Plus généralement, les algorithmes issus de stratégie <strong>diviser pour régner</strong> (<em>divide and conquer</em>) introduisent des complexités en <span class="math notranslate nohighlight">\(\log\)</span> : <span class="math notranslate nohighlight">\(\log(n)\)</span> ou <span class="math notranslate nohighlight">\(n \times \log(n)\)</span> et même <span class="math notranslate nohighlight">\(n \times \log( \log(n) )\)</span>.</p>
<p>Stratégie <strong>diviser pour régner</strong></p>
<ul class="simple">
<li><p>principe général basé sur la <em>récursivité</em></p></li>
<li><p>réduire le problème en un problème <em>similaire</em> ET de <em>taille réduite</em> …</p></li>
<li><p>… recommencer cette réduction …</p></li>
<li><p>… jusqu’à obtenir un problème suffisamment petit pour pouvoir trouver sa solution immédiatement,</p></li>
<li><p>à partir de cette solution, construire la solution du problème plus grand …</p></li>
<li><p>… et ainsi de suite jusqu’à obtenir la solution du problème de départ</p></li>
</ul>
<p><strong>Exercice.</strong>
Identifier que ce principe est présent dans la recherche dichotomique !</p>
</section>
</section>
<section id="complexite-asymptotique">
<span id="sec-complexiteasymptotique"></span><h2><span class="section-number">1.7. </span>Complexité asymptotique<a class="headerlink" href="#complexite-asymptotique" title="Permalink to this headline">#</a></h2>
<p>Section où sont introduites les <em>notations de Landau</em> largement utilisées en algorithmique.</p>
<section id="quelle-complexite">
<h3><span class="section-number">1.7.1. </span>Quelle complexité ?<a class="headerlink" href="#quelle-complexite" title="Permalink to this headline">#</a></h3>
<p>Ce qui importe : c’est <strong>l’ordre de grandeur</strong> du coût mesuré comme une fonction de la taille du problème, quelque soit l’instance du problème.</p>
<p>En effet, la question pratique pertinente est, par exemple pour la complexité en temps :</p>
<blockquote>
<div><p>Quel <strong>surcoût</strong> de temps pour résoudre un problème <strong>deux fois plus gros, dix fois plus gros ?</strong></p>
</div></blockquote>
<p>10 fois plus gros avec une complexité :</p>
<ul class="simple">
<li><p>cubique = 1000 fois plus long</p></li>
<li><p>quadratique = 100 fois plus long</p></li>
<li><p>linéaire = 10 fois plus long … à la rigueur</p></li>
<li><p>racine carrée = environ 3 fois plus long … oui !</p></li>
<li><p>logarithmique = 2 fois plus long … oui : je veux !</p></li>
<li><p>exponentiel = 1010 fois plus long … aie aie aie : trop cher pour moi !!!!</p></li>
</ul>
<p>Le même question se pose pour l’espace-mémoire nécessaire.</p>
<p><strong>Exercice.</strong> Il y a pire qu’exponentiel. Quoi ?</p>
</section>
<section id="complexite-asymptotique-et-notations-de-landau">
<h3><span class="section-number">1.7.2. </span>Complexité asymptotique et notations de Landau<a class="headerlink" href="#complexite-asymptotique-et-notations-de-landau" title="Permalink to this headline">#</a></h3>
<p>On formalise pour dégager les tendances asymptotiques.
On se focalise d’abord sur <strong>la tendance du pire cas</strong>.</p>
<p>Pour ce pire cas, un algorithme <span class="math notranslate nohighlight">\(\cal{A}\)</span> peut être par exemple pour la complexité en temps :</p>
<ul class="simple">
<li><p><strong>aussi</strong> rapide qu’un algorithme quadratique <span class="math notranslate nohighlight">\(\cal{Q}\)</span></p></li>
<li><p><strong>au moins aussi</strong> rapide qu’un algorithme quadratique <span class="math notranslate nohighlight">\(\cal{Q}\)</span></p></li>
<li><p><strong>au plus aussi</strong> rapide qu’un algorithme quadratique <span class="math notranslate nohighlight">\(\cal{Q}\)</span></p></li>
</ul>
<p>La <em>comparaisons asymptotique de fonctions</em> est adaptée à la description de ces 3 tendances. En notant <span class="math notranslate nohighlight">\(C_{\cal{A}}(n)\)</span> la complexité de l’algorithme  <span class="math notranslate nohighlight">\(\cal{A}\)</span>, on introduit <strong>les notations de Landau : <span class="math notranslate nohighlight">\(\Theta(), \Omega()\)</span> et <span class="math notranslate nohighlight">\(\cal{O}()\)</span></strong> pour caractériser respectivement les 3 tendances asymptotiques des pire cas de l’algorithme <span class="math notranslate nohighlight">\(\cal{A}\)</span> :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(C_{\cal{A}}(n) = \Theta(n^2)\)</span> : notion d’équivalent asymptotique</p></li>
<li><p><span class="math notranslate nohighlight">\(C_{\cal{A}}(n) = \Omega(n^2)\)</span> : notion de minorant asymptotique</p></li>
<li><p><span class="math notranslate nohighlight">\(C_{\cal{A}}(n) = \cal{O}(n^2)\)</span> : notion de <strong>majorant asymptotique</strong></p></li>
</ul>
<p>En pratique, la complexité asymptotique dans le pire des cas sera souvent décrite par son majorant asymptotique, <em>ie.</em> avec la notation <span class="math notranslate nohighlight">\(\cal{O}\)</span>. En effet, le décompte du coût du traitement s’exprime souvent plus facilement sous forme de majoration d’une certaine quantité atteinte dans le pire cas.</p>
<p>Attention : on n’a pas écrit que l’analyse d’un pire cas ne pouvait conduire qu’à une majoration.</p>
<section id="star-expression-formalisee-et-principales-proprietes-de-ces-notations">
<h4>(<span class="math notranslate nohighlight">\(\star\)</span>) Expression formalisée et principales propriétés de ces notations<a class="headerlink" href="#star-expression-formalisee-et-principales-proprietes-de-ces-notations" title="Permalink to this headline">#</a></h4>
<p>Majorant asymptotique  : <span class="math notranslate nohighlight">\(f = \cal{O}(g)\)</span> ssi :<br />
il existe une constante <span class="math notranslate nohighlight">\(c &gt; 0\)</span> et un entier <span class="math notranslate nohighlight">\(n_0\)</span> telle que pour tout <span class="math notranslate nohighlight">\(n \ge n_0\)</span>, <span class="math notranslate nohighlight">\(f(n) \le c \times g(n)\)</span>.</p>
<p>Minorant asymptotique  : <span class="math notranslate nohighlight">\(f = \cal{\Omega}(g)\)</span> ssi :<br />
il existe une constante <span class="math notranslate nohighlight">\(c &gt; 0\)</span> et un entier <span class="math notranslate nohighlight">\(n_0\)</span> telle que pour tout <span class="math notranslate nohighlight">\(n \ge n_0\)</span>, <span class="math notranslate nohighlight">\(f(n) \ge c \times g(n)\)</span>.</p>
<p>Equivalent asymptotique  : <span class="math notranslate nohighlight">\(f = \cal{\Theta}(g)\)</span> ssi :<br />
il existe deux constante <span class="math notranslate nohighlight">\(c_1, c_2 &gt;0\)</span> et un entier <span class="math notranslate nohighlight">\(n_0\)</span> telle que pour tout <span class="math notranslate nohighlight">\(n \ge n_0\)</span>, <span class="math notranslate nohighlight">\(c_1 \times g(n) \le  f(n) \le c_2 \times g(n)\)</span>.</p>
<p>Ce qui correspond aux schémas suivants.</p>
<figure class="align-default" id="fig-grando">
<a class="reference internal image-reference" href="../_images/landauO.png"><img alt="../_images/landauO.png" src="../_images/landauO.png" style="height: 120mm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1.3 </span><span class="caption-text"><span class="math notranslate nohighlight">\(f = \cal{O}(g)\)</span></span><a class="headerlink" href="#fig-grando" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-grandomega">
<a class="reference internal image-reference" href="../_images/landauOmega.png"><img alt="../_images/landauOmega.png" src="../_images/landauOmega.png" style="height: 120mm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1.4 </span><span class="caption-text"><span class="math notranslate nohighlight">\(f = \cal{\Omega}(g)\)</span></span><a class="headerlink" href="#fig-grandomega" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-grandthetha">
<a class="reference internal image-reference" href="../_images/landauTheta.png"><img alt="../_images/landauTheta.png" src="../_images/landauTheta.png" style="height: 120mm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1.5 </span><span class="caption-text"><span class="math notranslate nohighlight">\(f = \cal{\Theta}(g)\)</span></span><a class="headerlink" href="#fig-grandthetha" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p><strong>Vocabulaire</strong></p>
<p>On dit aussi <em><span class="math notranslate nohighlight">\(f\)</span> est dominée asymptotiquement par <span class="math notranslate nohighlight">\(g\)</span></em> lorsque <span class="math notranslate nohighlight">\(f = \cal{O}(g)\)</span>.</p>
<p><strong>Propriétés</strong></p>
<ul class="simple">
<li><p>transitivité : <span class="math notranslate nohighlight">\(f = \cal{O}(g)\)</span> et <span class="math notranslate nohighlight">\(g = \cal{O}(h)\)</span> alors <span class="math notranslate nohighlight">\(f = \cal{O}(h)\)</span></p></li>
<li><p>invariance par multiplication : si <span class="math notranslate nohighlight">\(f = \cal{O}(g)\)</span> alors <span class="math notranslate nohighlight">\(k \times f = \cal{O}(g)\)</span> pour <span class="math notranslate nohighlight">\(k &gt; 0\)</span></p></li>
<li><p>addition : <span class="math notranslate nohighlight">\(f1 = \cal{O}(g1)\)</span> et <span class="math notranslate nohighlight">\(f2 = \cal{O}(g2)\)</span> alors <span class="math notranslate nohighlight">\(f1+ f2 = \cal{O}(g1+g2)\)</span></p></li>
<li><p>multiplication : <span class="math notranslate nohighlight">\(f1 = \cal{O}(g1)\)</span> et <span class="math notranslate nohighlight">\(f2 = \cal{O}(g2)\)</span> alors <span class="math notranslate nohighlight">\(f1 \times f2 = \cal{O}(g1 \times g2)\)</span></p></li>
</ul>
<p><strong>Rappel.</strong>
Attention aux constantes multiplicatives cachées.</p>
<p>Ces bornes asymptotiques cachent des constantes multiplicatives qui peuvent faire la différence entre 2 algorithmes de même complexité
asymptotique.</p>
<figure class="align-default" id="fig-plt-complexite">
<a class="reference internal image-reference" href="../_images/plt-complexites.png"><img alt="../_images/plt-complexites.png" src="../_images/plt-complexites.png" style="height: 150mm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1.6 </span><span class="caption-text">Principales classes de complexité</span><a class="headerlink" href="#fig-plt-complexite" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="expressions-et-equivalents-asymptotiques-a-connaitre">
<h3><span class="section-number">1.7.3. </span>Expressions et équivalents asymptotiques à connaître<a class="headerlink" href="#expressions-et-equivalents-asymptotiques-a-connaitre" title="Permalink to this headline">#</a></h3>
<p>Fonction de complexité dans le cas itératif = sommes, polynômes, produits, factorielles (aie)</p>
<ul class="simple">
<li><p><strong>Somme arithmétique des n premiers entiers : <span class="math notranslate nohighlight">\(n(n+1)/2 = \Theta(n^2)\)</span></strong></p></li>
<li><p>Somme arithmétique des n premiers carrés : <span class="math notranslate nohighlight">\(n(n+1)(2n+1)/6 = \theta(n^3)\)</span></p></li>
<li><p>Somme arithmétique des n premiers cubes : <span class="math notranslate nohighlight">\(n^2(n+1)^2/4 = \theta(n^4)\)</span></p></li>
<li><p><strong>Polynôme en n de degré <span class="math notranslate nohighlight">\(\le\)</span> k et à coefficients constants = <span class="math notranslate nohighlight">\(\Theta(n^k)\)</span></strong></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(a_k n^k + a_{k-1} n^{k-1} + \dots + a_1 n + a_0 = \Theta(n^k)\)</span>.
-<strong>Série harmonique : <span class="math notranslate nohighlight">\(1+1/2+1/3+\dots+1/n = \ln(n) + \cal{O}(1)\)</span></strong></p></li>
</ul>
</li>
<li><p>Produits <span class="math notranslate nohighlight">\(\to\)</span> Sommes : <span class="math notranslate nohighlight">\(\ln(a_1 \times a_2 \times \dots \times a_n) = \ln(a_1) + ln(a_2) + \dots + \ln(a_n)\)</span></p></li>
</ul>
<p><strong>Ordres de grandeur pratiques</strong></p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Notation</p></th>
<th class="text-align:center head"><p>Dénomination</p></th>
<th class="text-align:center head"><p>Temps pour n = <span class="math notranslate nohighlight">\(10^6\)</span> et 1GHz</p></th>
<th class="text-align:center head"><p>Commentaires</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(\cal{O}(1)\)</span></p></td>
<td class="text-align:center"><p>temps constant</p></td>
<td class="text-align:center"><p>1 ns</p></td>
<td class="text-align:center"><p>rare</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(\cal{O}(log n)\)</span></p></td>
<td class="text-align:center"><p>logarithmique</p></td>
<td class="text-align:center"><p>10 ns</p></td>
<td class="text-align:center"><p>instantané ou presque. Il y a une constante cachée et du log2 en pratique</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(\cal{O}(n)\)</span></p></td>
<td class="text-align:center"><p>linéaire</p></td>
<td class="text-align:center"><p>1000 ns = 1 ms</p></td>
<td class="text-align:center"><p>sera supérieur à 1 min pour des tailles de pb comparables aux taille de RAM actuelles. Donc pb prédominant = gestion de la mémoire</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(\cal{O}(n^2)\)</span></p></td>
<td class="text-align:center"><p>quadratique</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1/4\)</span> h</p></td>
<td class="text-align:center"><p>ne pas dépasser n = <span class="math notranslate nohighlight">\(10^6\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(\cal{O}(n^k)\)</span></p></td>
<td class="text-align:center"><p>polynomiale</p></td>
<td class="text-align:center"><p>k= 3 <span class="math notranslate nohighlight">\(\to\)</span> 30 ans</p></td>
<td class="text-align:center"><p>et pourtant on en rencontre souvent</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(\cal{O}(2^n)\)</span></p></td>
<td class="text-align:center"><p>exponentielle</p></td>
<td class="text-align:center"><p>plus de 10300 000 milliards d’années</p></td>
<td class="text-align:center"><p>inutilisable en pratique sauf pour des tout petits problèmes : n &lt; 50</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="complexite-d-algorithmes-iteratifs">
<h2><span class="section-number">1.8. </span>Complexité d’algorithmes itératifs<a class="headerlink" href="#complexite-d-algorithmes-iteratifs" title="Permalink to this headline">#</a></h2>
<p>On explicite maintenant quelques expressions de fonctions de complexité d’algorithmes classiques ainsi que les expressions asymptotiques associées.</p>
<section id="iterations-classiques">
<h3><span class="section-number">1.8.1. </span>Itérations classiques<a class="headerlink" href="#iterations-classiques" title="Permalink to this headline">#</a></h3>
<p><strong>Boucle de n répétitions indépendantes de p instructions</strong> : <span class="math notranslate nohighlight">\(n \times p\)</span> avec p &lt; n quand n est grand</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">inst_1</span><span class="p">;</span> <span class="n">inst_2</span><span class="p">;</span> <span class="o">...</span><span class="p">,</span> <span class="n">inst_p</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\( \to \Theta(n)\)</span>, asymptotiquement linéaire</p>
<p><strong>Boucle de n répétitions dépendantes</strong> : <span class="math notranslate nohighlight">\(1+2+\dots+n = n(n+1)/2\)</span></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">inst_1</span><span class="p">;</span> <span class="o">...</span> <span class="p">;</span> <span class="n">inst_i</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\to \Theta(n^2)\)</span>, asymptotiquement quadratique</p>
<p><strong>Deux boucles imbriquées indépendantes de longueur n qui répètent p instructions</strong> : <span class="math notranslate nohighlight">\(n^2 \times p\)</span> avec p &lt;n quand n est grand</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">inst_1</span><span class="p">;</span> <span class="n">inst_2</span><span class="p">;</span> <span class="o">...</span><span class="p">,</span> <span class="n">inst_p</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\to \Theta(n^2)\)</span>, asymptotiquement quadratique</p>
<p><strong>Deux boucles imbriquées indépendantes de longueur n et corps de boucle interne dépendant</strong> :
<span class="math notranslate nohighlight">\(n(1+2+\dots+n) = n \times n(n+1)/2\)</span></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">inst_1</span><span class="p">;</span> <span class="o">...</span> <span class="p">;</span> <span class="n">inst_j</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\to \Theta(n^3)\)</span>, asymptotiquement cubique</p>
<p><strong>Répétition avec structure <code class="docutils literal notranslate"><span class="pre">while</span></code></strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">cond</span><span class="p">:</span>
    <span class="n">inst_1</span><span class="p">;</span> <span class="o">...</span> <span class="p">;</span> <span class="n">inst_p</span><span class="p">;</span>
</pre></div>
</div>
<p>Question : peut-on majorer le nombre de fois où <code class="docutils literal notranslate"><span class="pre">cond</span></code> est vérifiée ?<br />
Exemple : je parcours une liste (de longueur n) jusqu’à trouver une valeur donnée<br />
Réponse : <code class="docutils literal notranslate"><span class="pre">cond</span></code> est évaluée au plus (au pire) n ou n+1 fois (liste_non_vide, il_existe_un_élément_suivant)<br />
<span class="math notranslate nohighlight">\(\to \)</span> Complexité majorée par <span class="math notranslate nohighlight">\(n \times p\)</span>, <span class="math notranslate nohighlight">\(\cal{O}(n)\)</span>, asymptotiquement majorée linéairement</p>
</section>
</section>
<section id="star-complexite-d-algorithmes-recursifs">
<h2><span class="section-number">1.9. </span>(<span class="math notranslate nohighlight">\(\star\)</span>) Complexité d’algorithmes récursifs<a class="headerlink" href="#star-complexite-d-algorithmes-recursifs" title="Permalink to this headline">#</a></h2>
<section id="fonction-de-complexite-relation-de-recurrence">
<h3><span class="section-number">1.9.1. </span>Fonction de complexité = relation de récurrence<a class="headerlink" href="#fonction-de-complexite-relation-de-recurrence" title="Permalink to this headline">#</a></h3>
<p><strong>Exemple</strong> Forme récursive du calcul de <span class="math notranslate nohighlight">\(n!\)</span></p>
<p>La fonction de complexité s’écrit <span class="math notranslate nohighlight">\(C(n) = C(n-1) + 1\)</span></p>
<ul class="simple">
<li><p>l’appel récursif à <code class="docutils literal notranslate"><span class="pre">fact(n-1)</span></code> : <span class="math notranslate nohighlight">\(C(n-1)\)</span></p></li>
<li><p>1 multiplication : 1</p></li>
<li><p>(la comparaison : 1)</p></li>
</ul>
<p>et <span class="math notranslate nohighlight">\(C(0) = 1\)</span></p>
<p>On élimine la récurrence et on obtient : <span class="math notranslate nohighlight">\(C(n) = n+1\)</span>.</p>
<p>Complexité asymptotique : complexité linéaire (déjà vue).</p>
<p><strong>Exercice</strong>
Montrer que la forme récursive de l’exponentiation classique est d’une complexité identique.</p>
<p><strong>Expression de C(n) sous forme non récursive</strong></p>
<p>Il existe plusieurs méthodes dont celle des éliminations successives naturelle dans ce cas.</p>
<p><span class="math notranslate nohighlight">\(C(n) = C(n-1) + 1\)</span><br />
<span class="math notranslate nohighlight">\(C(n-1) = C(n-2) + 1\)</span><br />
<span class="math notranslate nohighlight">\(C(n-2) = \dots\)</span><br />
<span class="math notranslate nohighlight">\(\dots\)</span><br />
<span class="math notranslate nohighlight">\(C(2) = C(1) + 1\)</span><br />
<span class="math notranslate nohighlight">\(C(1) = C(0) + 1\)</span><br />
<span class="math notranslate nohighlight">\(C(0) = 1\)</span></p>
<p>On somme chaque ligne, les membres de gauche s’éliminent successivement excepté le premier et on obtient :</p>
<p><span class="math notranslate nohighlight">\(C(n) = 1 + 1 + \dots + 1 = n + 1\)</span></p>
<p>Les expressions récurrentes d’algorithmes récursives peuvent prendre des formes compliquées à réduire.
Quelques-unes sont classiques et à connaître.</p>
<p>On distingue deux familles de récurrences selon la variation de son indice.</p>
<ul class="simple">
<li><p>Les récursions décrémentales où les indices de deux itérations successives sont distants d’une valeur constante (1 ou <span class="math notranslate nohighlight">\(p\)</span>)</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(n \to n-1\)</span> ou <span class="math notranslate nohighlight">\(n \to n-p\)</span></p></li>
</ul>
</li>
<li><p>Les récursions “divide-and-conquer” où les indices de deux itérations successives varient <em>d’un facteur</em> constant et &gt; 1</p>
<ul>
<li><p>Les récursion dichotomiques en sont un exemple : <span class="math notranslate nohighlight">\(n \to n/2\)</span></p></li>
</ul>
</li>
</ul>
<p>On simplifie l’analyse de ces récurrences en fixant <strong><span class="math notranslate nohighlight">\(C(0)=1\)</span></strong>.</p>
</section>
<section id="c-n-fonction-de-c-n-1">
<h3><span class="section-number">1.9.2. </span><span class="math notranslate nohighlight">\(C(n)\)</span> fonction de <span class="math notranslate nohighlight">\(C(n-1)\)</span><a class="headerlink" href="#c-n-fonction-de-c-n-1" title="Permalink to this headline">#</a></h3>
<p><strong><span class="math notranslate nohighlight">\(C(n) = C(n-1) + b\)</span></strong></p>
<ul class="simple">
<li><p>exemples : factorielle, exponentiation naïve, recherche séquentielle récursive</p></li>
<li><p>cas <strong>linéaire</strong> : <span class="math notranslate nohighlight">\(C(n) = n \times b + C(0) = \Theta(n)\)</span></p></li>
<li><p>suite arithmétique de pas b</p></li>
</ul>
<p><strong><span class="math notranslate nohighlight">\(C(n) = C(n-1) + a \times n + b\)</span></strong></p>
<ul class="simple">
<li><p>exemples : traitement de coût linéaire avant l’appel récursif, tri à bulle</p></li>
<li><p>cas <strong>quadratique</strong> : <span class="math notranslate nohighlight">\(C(n) = a \times n(n+1)/2 + (n+1) \times b = \cal{O}(n^2)\)</span> pour <span class="math notranslate nohighlight">\(C(0)= b\)</span></p></li>
</ul>
<p><strong><span class="math notranslate nohighlight">\(C(n) = a \times C(n-1) + b\)</span></strong></p>
<ul class="simple">
<li><p>exemples : répéter a fois l’appel récursif</p></li>
<li><p>cas <strong>exponentiel</strong> : <span class="math notranslate nohighlight">\(C(n) = (a^{n+1} -1)b' = \theta(a^{n+1})\)</span>
avec <span class="math notranslate nohighlight">\(b' = b/(a-1)\)</span> pour <span class="math notranslate nohighlight">\(C(0)=b\)</span></p></li>
<li><p>suite arithmético-géométrique de raison a et de pas b</p></li>
</ul>
</section>
<section id="c-n-fonction-de-c-n-2">
<h3><span class="section-number">1.9.3. </span><span class="math notranslate nohighlight">\(C(n)\)</span> fonction de <span class="math notranslate nohighlight">\(C(n/2)\)</span><a class="headerlink" href="#c-n-fonction-de-c-n-2" title="Permalink to this headline">#</a></h3>
<p>Reconnaître le cas d’une récursion dichotomique et l’apparition de <span class="math notranslate nohighlight">\(\log_2\)</span> dans la fonction de complexité.</p>
<p><strong><span class="math notranslate nohighlight">\(C(n) = C(n/2) + b\)</span></strong></p>
<ul class="simple">
<li><p>exemples : exponentiation rapide, élimination de la moitié des valeurs en temps constant, recherche dichotomique</p></li>
<li><p>cas <strong>logarithmique</strong>: <span class="math notranslate nohighlight">\(C(n) = C(1) + b \times log_2(n) = \cal{O}(\log(n))\)</span></p></li>
</ul>
<p><strong><span class="math notranslate nohighlight">\(C(n) = C(n/2) + n\)</span></strong></p>
<ul class="simple">
<li><p>exemples : traitement linéaire avant appel récursif dichotomique</p></li>
<li><p>cas <strong>linéaire</strong>: <span class="math notranslate nohighlight">\(C(n) = \cal{O}(n)\)</span></p></li>
</ul>
<p><strong><span class="math notranslate nohighlight">\(C(n) = 2 \times C(n/2) + a \times n + b, a \neq 1\)</span></strong></p>
<ul class="simple">
<li><p>exemples : traitement linéaire avant 2 appels récursifs dichotomiques, tri fusion</p></li>
<li><p>cas <strong>semi-logarithmique</strong> : <span class="math notranslate nohighlight">\(C(n) = \cal{O}(n \log(n))\)</span></p></li>
</ul>
<p><strong><span class="math notranslate nohighlight">\(C(n) = a \times C(n/2) + b, a \neq 1\)</span></strong></p>
<ul class="simple">
<li><p>exemples : répéter <span class="math notranslate nohighlight">\(a\)</span> fois l’appel récursif dichotomique</p></li>
<li><p>cas <strong>polynomial</strong> : <span class="math notranslate nohighlight">\(C(n) = cal{O}(n^{\log_2 a})\)</span></p></li>
</ul>
</section>
<section id="star-star-autres-cas">
<h3><span class="section-number">1.9.4. </span>(<span class="math notranslate nohighlight">\(\star\star\)</span>) Autres cas<a class="headerlink" href="#star-star-autres-cas" title="Permalink to this headline">#</a></h3>
<p>Selon le traitement récursif et la stratégie <em>divide-and-conquer</em>, la fonction de complexité peut prendre une forme plus générale comme :</p>
<p><span class="math notranslate nohighlight">\(C(n) = a \times C(n/b) + c \times n^k + d\)</span> pour <span class="math notranslate nohighlight">\(b \ge 2, k \ge 0\)</span> et <span class="math notranslate nohighlight">\(a, c, d &gt; 0\)</span>.</p>
<p>Un théorème basé sur la comparaison de <span class="math notranslate nohighlight">\(a\)</span> et de <span class="math notranslate nohighlight">\(b^k\)</span> (ou de façon équivalente la comparaison de <span class="math notranslate nohighlight">\(\log_b(a)\)</span> et <span class="math notranslate nohighlight">\(k\)</span>) fournit l’expression du comportement asymptotique de la fonction de complexité <span class="math notranslate nohighlight">\(C(n)\)</span>.</p>
</section>
</section>
<section id="synthese">
<h2><span class="section-number">1.10. </span>Synthèse<a class="headerlink" href="#synthese" title="Permalink to this headline">#</a></h2>
<p><strong>Complexités en temps et en espace</strong></p>
<ul class="simple">
<li><p>principe, objectif général et modèle d’analyse de complexité</p></li>
<li><p>identifier ce qu’il est significatif de mesurer et le paramètre du problème qui dirige cette mesure</p></li>
<li><p>distinguer pires cas <em>vs.</em> meilleurs cas</p></li>
<li><p>savoir comment on compte dans les cas itératifs ou récursifs</p></li>
</ul>
<p><strong>Complexité asymptotique</strong></p>
<ul class="simple">
<li><p>notations de Landau : <span class="math notranslate nohighlight">\(\cal{O}, \Omega, \theta\)</span> et leurs propriétés</p></li>
<li><p>savoir conclure : quel est le sur-coût quand je multiplie la taille de mon problème par \dots ?</p></li>
</ul>
<p><strong>Exemples significatifs d’algorithmes de différentes complexités en temps</strong></p>
<ul class="simple">
<li><p>logarithmique : recherche dichotomique dans une liste triée</p></li>
<li><p>linéaire : sommes, parcours ou recherche itérative, …</p></li>
<li><p>polynomiale : quadratique (produit matrice-vecteur, certains algorithmes itératifs de tris), cubique (produit matrice-matrice)</p></li>
<li><p>semi-linéaire <span class="math notranslate nohighlight">\(n \log(n)\)</span> : certains algorithmes récursifs de tris</p></li>
</ul>
<p><strong>Réduire la complexité : pourquoi ? toujours possible ? comment ?</strong></p>
<ul class="simple">
<li><p>pour résoudre des problèmes de grande taille</p></li>
<li><p>mais aussi des problèmes pas nécessairement “gros” mais compliqués</p></li>
<li><p><strong>Il existe de nombreux problèmes qu’on se sait pas résoudre exactement en un temps réaliste, souvent des problèmes d’optimisation : min, max, le plus court, …</strong></p>
<ul>
<li><p>complexité exponentielle : problème du sac à dos <span class="math notranslate nohighlight">\(\to 2^n\)</span> configurations à tester pour (par force brute)</p></li>
<li><p>complexité factorielle : problème du voyageur de commerce <span class="math notranslate nohighlight">\(\to n!\)</span> parcours à tester (naïf)</p></li>
<li><p>en pratique (source wikipedia, temps de base = 10 nanosec)</p></li>
<li><p>exponentielle : pour n = 50, temps T = 130 jours,</p></li>
<li><p>exponentielle : pour n= 250 = <span class="math notranslate nohighlight">\(10^{59}\)</span> ans !</p></li>
<li><p>factorielle : pour n = 50, temps T = <span class="math notranslate nohighlight">\(10^{48}\)</span> ans</p></li>
</ul>
</li>
</ul>
<p><strong>Pertinence pratique du modèle utilisé et de l’analyse menée</strong></p>
<ul class="simple">
<li><p>modèle simple <em>vs.</em> exécution machine complexe</p>
<ul>
<li><p>lecture-écriture mémoire : tout sauf du temps constant, compliqué</p></li>
<li><p>opération arithmétique : addition <em>vs.</em> division, entier <em>vs.</em> flottant</p></li>
<li><p>exécution séquentielle des instructions : ça n’existe plus – ou presque plus</p>
<ul>
<li><p>les machines actuelles exécutent plusieurs instructions en
parallèle, dans un ordre différent du programme, elles
spéculent sur le résultats de tests ou d’accès mémoire …</p></li>
</ul>
</li>
<li><p><strong>les estimations asymptotiques (grande taille du pb) masquent ces effets</strong></p></li>
<li><p>demain : calcul quantique ?</p></li>
</ul>
</li>
</ul>
<p><strong>Complexité algorithmique</strong></p>
<ul class="simple">
<li><p>une sensibilisation à une première notion d’informatique théorique</p></li>
<li><p>nos premiers objectifs :</p>
<ul>
<li><p>mieux comprendre l’efficacité d’un algorithme</p></li>
<li><p>estimer les effets de la taille d’un problème sur le temps de résolution</p></li>
</ul>
</li>
<li><p>théorie de la complexité : une branche de l’informatique</p>
<ul>
<li><p>objectif : classer les problèmes selon leurs difficultés de
résolution, c-a-d. le coût de leur résolution <em>quelque soit
l’algorithme</em> utilisé et les relations entre ces classes de
problèmes</p></li>
<li><p>modèles d’exécution : RAM (ici, Random Access Memory),
machines de Turing (“dites” déterministes ou non déterministes),
automates, …</p></li>
</ul>
</li>
<li><p>autres aspects théoriques à voir ce semestre (peut-être)</p>
<ul>
<li><p>terminaison, correction et preuves</p></li>
</ul>
</li>
</ul>
<section id="avoir-les-idees-claires">
<h3><span class="section-number">1.10.1. </span>Avoir les idées claires<a class="headerlink" href="#avoir-les-idees-claires" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Connaître le principes de l’analyse de la complexité en temps : modèle de calcul, mesure et paramètre de la complexité, meilleur et pire cas</p></li>
<li><p>Savoir exprimer et exploiter une complexité asymptotique : notations de Landau, principales classes de complexité des algorithmes, interprétation pratique de ces classes</p></li>
<li><p>Savoir établir la complexité d’algorithmes itératifs simples ou récursifs terminaux.</p></li>
</ul>
</section>
<section id="savoir-faire">
<h3><span class="section-number">1.10.2. </span>Savoir-faire<a class="headerlink" href="#savoir-faire" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Connaître des exemples significatifs d’algorithmes de complexité polynomiale et logarithmique (complexité, pires et meilleurs cas)</p></li>
<li><p>Savoir identifier (sans nécessairement le prouver) la complexité, les meilleur-pire cas d’un algorithme</p></li>
</ul>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./cm"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="3-ES-fichiers.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">2. </span>Entrées-sorties simples avec des fichiers</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="6-recursivite.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2. </span>Récursivité</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Ph. Langlois<br/>
  
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>